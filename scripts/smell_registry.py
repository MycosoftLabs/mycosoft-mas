"""
MINDEX Smell Registry API

Manages BSEC selectivity blobs and smell signatures for the
world's largest fungal smell database.

Part of the MINDEX Automated Smell Training System.
"""

import hashlib
import base64
import json
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any
from dataclasses import dataclass, asdict
from enum import Enum


class SmellCategory(str, Enum):
    FUNGAL = "fungal"
    PLANT = "plant"
    CHEMICAL = "chemical"
    ANIMAL = "animal"
    FIRE = "fire"
    DECAY = "decay"
    CLEAN = "clean"


class BlobStatus(str, Enum):
    ACTIVE = "active"
    TESTING = "testing"
    DEPRECATED = "deprecated"


@dataclass
class SmellSignature:
    """Represents a smell signature in the MINDEX database."""
    id: str
    name: str
    category: SmellCategory
    subcategory: str
    description: str
    bsec_class_id: int  # 0-3 for BSEC, -1 for no class
    voc_pattern: Dict[str, float]
    icon_type: str
    color_hex: str
    species_id: Optional[str] = None
    species_name: Optional[str] = None
    training_samples: int = 0
    confidence_threshold: float = 0.75
    current_blob_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        d = asdict(self)
        d["category"] = self.category.value
        return d


@dataclass
class SmellBlob:
    """Represents a BSEC selectivity configuration blob."""
    id: str
    name: str
    version: str
    description: str
    training_date: str
    training_samples: int
    training_method: str  # ai_studio, edge_impulse, custom
    class_labels: List[str]
    class_count: int
    blob_data: bytes
    blob_hash: str
    blob_size_bytes: int
    bsec_version: str
    sensor_model: str
    f1_score: Optional[float] = None
    accuracy: Optional[float] = None
    confusion_matrix: Optional[Dict] = None
    status: BlobStatus = BlobStatus.ACTIVE
    created_at: Optional[str] = None
    created_by: Optional[str] = None
    
    @classmethod
    def from_file(
        cls,
        file_path: str,
        name: str,
        version: str,
        class_labels: List[str],
        description: str = "",
        training_method: str = "ai_studio",
        bsec_version: str = "2.4.0",
        sensor_model: str = "BME688"
    ) -> "SmellBlob":
        """Create a SmellBlob from a BSEC config file."""
        path = Path(file_path)
        blob_data = path.read_bytes()
        blob_hash = hashlib.sha256(blob_data).hexdigest()
        
        return cls(
            id=f"blob-{blob_hash[:12]}",
            name=name,
            version=version,
            description=description,
            training_date=datetime.now().isoformat(),
            training_samples=0,
            training_method=training_method,
            class_labels=class_labels,
            class_count=len(class_labels),
            blob_data=blob_data,
            blob_hash=blob_hash,
            blob_size_bytes=len(blob_data),
            bsec_version=bsec_version,
            sensor_model=sensor_model,
            created_at=datetime.now().isoformat()
        )
    
    def to_c_header(self) -> str:
        """Generate C/C++ header file for Arduino/ESP32."""
        safe_name = self.name.replace("-", "_").replace(" ", "_").lower()
        
        # Format bytes as C array
        bytes_list = list(self.blob_data)
        bytes_per_line = 16
        lines = []
        
        for i in range(0, len(bytes_list), bytes_per_line):
            chunk = bytes_list[i:i + bytes_per_line]
            line = ",".join(str(b) for b in chunk)
            lines.append(f"  {line}")
        
        bytes_str = ",\n".join(lines)
        
        return f"""#pragma once
#include <stdint.h>

/**
 * BSEC Selectivity Configuration: {self.name}
 * 
 * Generated by MINDEX Smell Registry
 * Version: {self.version}
 * BSEC Version: {self.bsec_version}
 * Sensor: {self.sensor_model}
 * Classes: {', '.join(self.class_labels)}
 * Training Samples: {self.training_samples}
 * Blob Size: {self.blob_size_bytes} bytes
 * Hash: {self.blob_hash}
 * Generated: {self.created_at}
 */

static const uint8_t bsec_selectivity_config[{self.blob_size_bytes}] = {{
{bytes_str}
}};

static const size_t bsec_selectivity_config_len = sizeof(bsec_selectivity_config);

// Class label definitions
#define BSEC_CLASS_COUNT {self.class_count}
"""
    
    def to_csv(self) -> str:
        """Export blob data as CSV (for import to AI-Studio)."""
        return ",".join(str(b) for b in self.blob_data)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary (without raw blob data)."""
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "description": self.description,
            "training_date": self.training_date,
            "training_samples": self.training_samples,
            "training_method": self.training_method,
            "class_labels": self.class_labels,
            "class_count": self.class_count,
            "blob_hash": self.blob_hash,
            "blob_size_bytes": self.blob_size_bytes,
            "bsec_version": self.bsec_version,
            "sensor_model": self.sensor_model,
            "f1_score": self.f1_score,
            "accuracy": self.accuracy,
            "status": self.status.value,
            "created_at": self.created_at,
            "created_by": self.created_by
        }


class SmellRegistry:
    """
    MINDEX Smell Registry - manages smell signatures and BSEC blobs.
    
    This is a file-based implementation. For production, this should
    be backed by PostgreSQL + MinIO/S3.
    """
    
    def __init__(self, data_dir: str = "mindex_smell_data"):
        self.data_dir = Path(data_dir)
        self.signatures_dir = self.data_dir / "signatures"
        self.blobs_dir = self.data_dir / "blobs"
        
        # Create directories
        self.signatures_dir.mkdir(parents=True, exist_ok=True)
        self.blobs_dir.mkdir(parents=True, exist_ok=True)
        
        # Load indexes
        self._load_indexes()
    
    def _load_indexes(self):
        """Load signature and blob indexes."""
        self.signatures: Dict[str, SmellSignature] = {}
        self.blobs: Dict[str, SmellBlob] = {}
        
        # Load signatures
        for sig_file in self.signatures_dir.glob("*.json"):
            try:
                with open(sig_file) as f:
                    data = json.load(f)
                data["category"] = SmellCategory(data.get("category", "fungal"))
                sig = SmellSignature(**data)
                self.signatures[sig.id] = sig
            except Exception as e:
                print(f"Warning: Failed to load signature {sig_file}: {e}")
        
        # Load blob metadata (not the actual blob data)
        for blob_file in self.blobs_dir.glob("*.json"):
            try:
                with open(blob_file) as f:
                    data = json.load(f)
                # Don't load blob_data here - load on demand
                data["blob_data"] = b""
                data["status"] = BlobStatus(data.get("status", "active"))
                blob = SmellBlob(**data)
                self.blobs[blob.id] = blob
            except Exception as e:
                print(f"Warning: Failed to load blob {blob_file}: {e}")
    
    # ==================== SIGNATURES ====================
    
    def add_signature(self, signature: SmellSignature) -> str:
        """Add a new smell signature."""
        signature.created_at = datetime.now().isoformat()
        signature.updated_at = signature.created_at
        
        # Save to file
        sig_file = self.signatures_dir / f"{signature.id}.json"
        with open(sig_file, "w") as f:
            json.dump(signature.to_dict(), f, indent=2)
        
        self.signatures[signature.id] = signature
        return signature.id
    
    def get_signature(self, sig_id: str) -> Optional[SmellSignature]:
        """Get a signature by ID."""
        return self.signatures.get(sig_id)
    
    def search_signatures(
        self,
        category: Optional[SmellCategory] = None,
        query: Optional[str] = None,
        bsec_class: Optional[int] = None
    ) -> List[SmellSignature]:
        """Search signatures by criteria."""
        results = list(self.signatures.values())
        
        if category:
            results = [s for s in results if s.category == category]
        
        if bsec_class is not None:
            results = [s for s in results if s.bsec_class_id == bsec_class]
        
        if query:
            query_lower = query.lower()
            results = [
                s for s in results
                if query_lower in s.name.lower()
                or query_lower in s.description.lower()
                or (s.species_name and query_lower in s.species_name.lower())
            ]
        
        return results
    
    def list_signatures(self) -> List[SmellSignature]:
        """List all signatures."""
        return list(self.signatures.values())
    
    # ==================== BLOBS ====================
    
    def add_blob(self, blob: SmellBlob) -> str:
        """Add a new BSEC blob."""
        blob.created_at = datetime.now().isoformat()
        
        # Check for duplicate hash
        for existing in self.blobs.values():
            if existing.blob_hash == blob.blob_hash:
                raise ValueError(f"Blob with hash {blob.blob_hash} already exists")
        
        # Save blob data to binary file
        blob_data_file = self.blobs_dir / f"{blob.id}.config"
        blob_data_file.write_bytes(blob.blob_data)
        
        # Save metadata to JSON
        blob_meta = blob.to_dict()
        blob_meta_file = self.blobs_dir / f"{blob.id}.json"
        with open(blob_meta_file, "w") as f:
            json.dump(blob_meta, f, indent=2)
        
        # Store without blob data
        blob.blob_data = b""
        self.blobs[blob.id] = blob
        
        return blob.id
    
    def get_blob(self, blob_id: str, include_data: bool = False) -> Optional[SmellBlob]:
        """Get a blob by ID."""
        blob = self.blobs.get(blob_id)
        if not blob:
            return None
        
        if include_data:
            blob_data_file = self.blobs_dir / f"{blob_id}.config"
            if blob_data_file.exists():
                blob.blob_data = blob_data_file.read_bytes()
        
        return blob
    
    def get_blob_data(self, blob_id: str) -> Optional[bytes]:
        """Get raw blob data."""
        blob_data_file = self.blobs_dir / f"{blob_id}.config"
        if blob_data_file.exists():
            return blob_data_file.read_bytes()
        return None
    
    def get_blob_as_header(self, blob_id: str) -> Optional[str]:
        """Get blob as C header file."""
        blob = self.get_blob(blob_id, include_data=True)
        if blob and blob.blob_data:
            return blob.to_c_header()
        return None
    
    def search_blobs(
        self,
        status: Optional[BlobStatus] = None,
        sensor_model: Optional[str] = None,
        min_accuracy: Optional[float] = None
    ) -> List[SmellBlob]:
        """Search blobs by criteria."""
        results = list(self.blobs.values())
        
        if status:
            results = [b for b in results if b.status == status]
        
        if sensor_model:
            results = [b for b in results if b.sensor_model == sensor_model]
        
        if min_accuracy is not None:
            results = [
                b for b in results 
                if b.accuracy is not None and b.accuracy >= min_accuracy
            ]
        
        return results
    
    def list_blobs(self) -> List[SmellBlob]:
        """List all blobs."""
        return list(self.blobs.values())
    
    def set_blob_status(self, blob_id: str, status: BlobStatus) -> bool:
        """Update blob status."""
        blob = self.blobs.get(blob_id)
        if not blob:
            return False
        
        blob.status = status
        
        # Update metadata file
        blob_meta_file = self.blobs_dir / f"{blob_id}.json"
        if blob_meta_file.exists():
            with open(blob_meta_file) as f:
                meta = json.load(f)
            meta["status"] = status.value
            with open(blob_meta_file, "w") as f:
                json.dump(meta, f, indent=2)
        
        return True
    
    # ==================== IMPORT/EXPORT ====================
    
    def import_blob_from_file(
        self,
        file_path: str,
        name: str,
        version: str,
        class_labels: List[str],
        **kwargs
    ) -> str:
        """Import a blob from a config file."""
        blob = SmellBlob.from_file(
            file_path=file_path,
            name=name,
            version=version,
            class_labels=class_labels,
            **kwargs
        )
        return self.add_blob(blob)
    
    def export_blob_to_header(self, blob_id: str, output_path: str) -> bool:
        """Export blob as C header file."""
        header = self.get_blob_as_header(blob_id)
        if header:
            Path(output_path).write_text(header)
            return True
        return False
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get registry statistics."""
        return {
            "total_signatures": len(self.signatures),
            "total_blobs": len(self.blobs),
            "active_blobs": len([b for b in self.blobs.values() if b.status == BlobStatus.ACTIVE]),
            "categories": list(set(s.category.value for s in self.signatures.values())),
            "total_training_samples": sum(s.training_samples for s in self.signatures.values())
        }


# ==================== DEFAULT FUNGAL SMELLS ====================

DEFAULT_FUNGAL_SIGNATURES = [
    SmellSignature(
        id="smell-001",
        name="Fresh Mushroom Fruiting",
        category=SmellCategory.FUNGAL,
        subcategory="basidiomycete",
        description="The characteristic earthy, umami smell of fresh mushroom fruiting bodies. Dominated by 1-octen-3-ol (mushroom alcohol).",
        bsec_class_id=0,
        voc_pattern={"octanol": 0.45, "ethanol": 0.25, "acetaldehyde": 0.15, "other": 0.15},
        icon_type="mushroom",
        color_hex="#8B4513",
        confidence_threshold=0.75
    ),
    SmellSignature(
        id="smell-002",
        name="Active Mycelium Growth",
        category=SmellCategory.FUNGAL,
        subcategory="mycelial",
        description="Earthy, musty smell of actively growing mycelium colonizing substrate.",
        bsec_class_id=1,
        voc_pattern={"ethanol": 0.30, "octanol": 0.20, "co2": 0.25, "other": 0.25},
        icon_type="mycelium",
        color_hex="#F5F5DC",
        confidence_threshold=0.70
    ),
    SmellSignature(
        id="smell-003",
        name="Substrate Decomposition",
        category=SmellCategory.DECAY,
        subcategory="fermentation",
        description="Fermentation and decomposition smell from substrate breakdown.",
        bsec_class_id=2,
        voc_pattern={"ethanol": 0.20, "ammonia": 0.25, "hydrogen_sulfide": 0.15, "co2": 0.20, "other": 0.20},
        icon_type="decay",
        color_hex="#654321",
        confidence_threshold=0.65
    ),
    SmellSignature(
        id="smell-004",
        name="Contamination Alert",
        category=SmellCategory.FUNGAL,
        subcategory="contamination",
        description="Unusual VOC profile indicating possible contamination (Trichoderma, bacteria, mold).",
        bsec_class_id=3,
        voc_pattern={"acetaldehyde": 0.30, "ammonia": 0.20, "hydrogen_sulfide": 0.20, "other": 0.30},
        icon_type="warning",
        color_hex="#FF4500",
        confidence_threshold=0.60
    ),
    SmellSignature(
        id="smell-010",
        name="Pleurotus ostreatus",
        category=SmellCategory.FUNGAL,
        subcategory="basidiomycete",
        description="Oyster mushroom. Mild anise-like undertones with classic mushroom earthiness.",
        bsec_class_id=0,
        voc_pattern={"octanol": 0.40, "ethanol": 0.25, "acetaldehyde": 0.15, "other": 0.20},
        icon_type="mushroom",
        color_hex="#D3D3D3",
        species_id="species-pleurotus-ostreatus",
        species_name="Pleurotus ostreatus",
        confidence_threshold=0.80
    ),
    SmellSignature(
        id="smell-011",
        name="Lentinula edodes",
        category=SmellCategory.FUNGAL,
        subcategory="basidiomycete",
        description="Shiitake mushroom. Strong umami with woody, smoky undertones.",
        bsec_class_id=0,
        voc_pattern={"octanol": 0.35, "ethanol": 0.30, "acetaldehyde": 0.20, "other": 0.15},
        icon_type="mushroom",
        color_hex="#8B4513",
        species_id="species-lentinula-edodes",
        species_name="Lentinula edodes",
        confidence_threshold=0.80
    ),
    SmellSignature(
        id="smell-020",
        name="Trichoderma viride",
        category=SmellCategory.FUNGAL,
        subcategory="contamination",
        description="Green mold contamination. Coconut-like sweet smell that indicates crop loss.",
        bsec_class_id=3,
        voc_pattern={"ethanol": 0.35, "acetaldehyde": 0.25, "other": 0.40},
        icon_type="warning",
        color_hex="#228B22",
        species_id="species-trichoderma-viride",
        species_name="Trichoderma viride",
        confidence_threshold=0.70
    ),
    SmellSignature(
        id="smell-000",
        name="Clean Air Baseline",
        category=SmellCategory.CLEAN,
        subcategory="baseline",
        description="Clean ambient air with no significant VOC signatures. Used as reference.",
        bsec_class_id=-1,
        voc_pattern={"co2": 0.05, "other": 0.05},
        icon_type="clean",
        color_hex="#87CEEB",
        confidence_threshold=0.90
    )
]


def initialize_default_registry(data_dir: str = "mindex_smell_data") -> SmellRegistry:
    """Initialize registry with default fungal smells."""
    registry = SmellRegistry(data_dir)
    
    # Add default signatures if empty
    if len(registry.signatures) == 0:
        print("Initializing MINDEX Smell Registry with default fungal signatures...")
        for sig in DEFAULT_FUNGAL_SIGNATURES:
            registry.add_signature(sig)
        print(f"Added {len(DEFAULT_FUNGAL_SIGNATURES)} default signatures")
    
    return registry


# ==================== CLI ====================

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="MINDEX Smell Registry CLI")
    subparsers = parser.add_subparsers(dest="command")
    
    # Init command
    init_parser = subparsers.add_parser("init", help="Initialize registry")
    init_parser.add_argument("--dir", default="mindex_smell_data")
    
    # List command
    list_parser = subparsers.add_parser("list", help="List signatures/blobs")
    list_parser.add_argument("type", choices=["signatures", "blobs"])
    list_parser.add_argument("--dir", default="mindex_smell_data")
    
    # Import blob command
    import_parser = subparsers.add_parser("import-blob", help="Import a blob file")
    import_parser.add_argument("file", help="Path to blob config file")
    import_parser.add_argument("--name", required=True)
    import_parser.add_argument("--version", default="1.0.0")
    import_parser.add_argument("--classes", required=True, help="Comma-separated class labels")
    import_parser.add_argument("--dir", default="mindex_smell_data")
    
    # Export blob command
    export_parser = subparsers.add_parser("export-blob", help="Export blob as header")
    export_parser.add_argument("blob_id")
    export_parser.add_argument("output", help="Output .h file path")
    export_parser.add_argument("--dir", default="mindex_smell_data")
    
    # Stats command
    stats_parser = subparsers.add_parser("stats", help="Show registry statistics")
    stats_parser.add_argument("--dir", default="mindex_smell_data")
    
    args = parser.parse_args()
    
    if args.command == "init":
        registry = initialize_default_registry(args.dir)
        stats = registry.get_statistics()
        print(f"Registry initialized: {stats}")
    
    elif args.command == "list":
        registry = SmellRegistry(args.dir)
        if args.type == "signatures":
            for sig in registry.list_signatures():
                print(f"  [{sig.id}] {sig.name} ({sig.category.value})")
        else:
            for blob in registry.list_blobs():
                print(f"  [{blob.id}] {blob.name} v{blob.version} - {blob.status.value}")
    
    elif args.command == "import-blob":
        registry = SmellRegistry(args.dir)
        classes = [c.strip() for c in args.classes.split(",")]
        blob_id = registry.import_blob_from_file(
            file_path=args.file,
            name=args.name,
            version=args.version,
            class_labels=classes
        )
        print(f"Imported blob: {blob_id}")
    
    elif args.command == "export-blob":
        registry = SmellRegistry(args.dir)
        if registry.export_blob_to_header(args.blob_id, args.output):
            print(f"Exported to: {args.output}")
        else:
            print(f"Blob not found: {args.blob_id}")
    
    elif args.command == "stats":
        registry = SmellRegistry(args.dir)
        stats = registry.get_statistics()
        print("MINDEX Smell Registry Statistics:")
        for key, value in stats.items():
            print(f"  {key}: {value}")
    
    else:
        parser.print_help()

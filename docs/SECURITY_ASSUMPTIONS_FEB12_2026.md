# Security Assumptions and Trust Model - February 12, 2026

**Status**: DRAFT  
**Version**: 1.0  
**Date**: February 12, 2026  
**Author**: security-auditor agent

---

## Purpose

This document explicitly states the security assumptions underlying the Mycosoft Multi-Agent System (MAS) and the MYCA autonomous coding system. Understanding what we trust and what we don't is critical for secure system design and operation.

---

## Trust Model

### What We TRUST

| Component | Trust Level | Reasoning |
|-----------|-------------|-----------|
| **MAS Orchestrator** | HIGH | Core system component, controlled by us |
| **PostgreSQL Database** | HIGH | Deployed on trusted VMs, physical access controlled |
| **VMs (187, 188, 189)** | HIGH | Managed by us, physical access controlled, SSH keys secured |
| **Docker Images** | MEDIUM | Built by us, but base images from Docker Hub |
| **Environment Variables** | MEDIUM | Set by administrators, but visible to processes |
| **Local Filesystem** | MEDIUM | Controlled by us, but agents can read/write |
| **Internal Network** | MEDIUM | Private 192.168.0.x network, but no encryption |

### What We DO NOT TRUST

| Component | Trust Level | Reasoning |
|-----------|-------------|-----------|
| **LLM Outputs** | NONE | AI models can be manipulated, hallucinate, or generate malicious code |
| **User Task Descriptions** | NONE | Users may intentionally or accidentally inject malicious content |
| **External API Responses** | NONE | Third-party APIs may be compromised or return malicious data |
| **Agent-Generated Code** | LOW | Code generated by agents must be reviewed before production |
| **Public Internet** | NONE | Assume all internet traffic is hostile |
| **Git Repositories (External)** | LOW | Clone repos may contain malicious code |

---

## Security Boundaries

### 1. Container Isolation

**Boundary**: Docker containers isolate each agent and service.

**Guarantees**:
- Process isolation (separate PIDs, namespaces)
- Filesystem isolation (read-only base images)
- Network isolation (container networks)

**Limitations**:
- Containers share the same kernel
- Privileged containers can escape
- Root in container ≠ security
- Resource limits can be exceeded

**Best Practices**:
- Never run containers as root
- Never use `--privileged` flag
- Always set resource limits (CPU, memory)
- Use read-only filesystem where possible
- Don't mount sensitive host paths

### 2. Filesystem Sandboxing

**Boundary**: Agents operate in restricted directory trees.

**Guarantees**:
- Path validation before file access
- No access to system directories (`/etc`, `/sys`, `/proc`)
- Limited write access (workspace only)

**Limitations**:
- Agents can still access files within their workspace
- Symbolic links can escape sandbox
- Shared volumes can be accessed
- Temporary files in `/tmp` shared

**Best Practices**:
- Always validate file paths before access
- Resolve symlinks before checking paths
- Use separate `/tmp` per container
- Log all file operations

### 3. Network Segmentation

**Boundary**: VMs on private network (192.168.0.x), no direct internet access.

**Guarantees**:
- VMs can only talk to each other
- No inbound connections from internet
- Outbound connections via proxy/NAT

**Limitations**:
- No encryption between VMs
- Network snooping possible on LAN
- No authentication on internal APIs
- SSRF attacks can reach internal services

**Best Practices**:
- Use HTTPS for all external connections
- Consider VPN or WireGuard for VM-to-VM
- Implement authentication on all APIs
- Validate URLs before fetching

### 4. Database Access Control

**Current State**: Single `mycosoft` user with full permissions.

**Future State** (planned):
- Separate users per subsystem
- Row-level security policies
- Audit logging for all queries
- Connection pooling with per-user credentials

**Limitations**:
- No fine-grained permissions yet
- All agents can access all data
- No data classification or labeling
- No query validation or filtering

### 5. API Authentication

**Current State**: No authentication on internal APIs (MAS ↔ MINDEX).

**Future State** (planned):
- JWT tokens for all API requests
- API key rotation
- Rate limiting per user
- Request signature verification

**Limitations**:
- Anyone on internal network can call APIs
- No request replay protection
- No input validation on all endpoints
- No audit logging for API calls

---

## Known Security Limitations

### 1. Claude Code CLI with `--dangerously-skip-permissions`

**Risk**: HIGH

**Description**: The CodingAgent invokes Claude Code CLI with `--dangerously-skip-permissions` flag, which disables all permission prompts and allows arbitrary code execution.

**Justification**: Required for autonomous operation; manual permission prompts would block agent execution.

**Mitigations**:
- Task descriptions are validated before passing to Claude Code
- Shell command arguments use `shlex.quote()` for escaping
- File system access limited to workspace directories
- All commands are logged for audit

**Residual Risk**: Malicious task description could still result in unintended code execution.

**Future Improvement**: Implement custom permission system that auto-approves safe operations and blocks dangerous ones.

### 2. Agents Can Execute Arbitrary Shell Commands

**Risk**: HIGH

**Description**: By design, agents (especially CodingAgent) can execute arbitrary shell commands on the host system.

**Justification**: Required for autonomous coding tasks (git, build tools, testing, deployment).

**Mitigations**:
- Commands run in Docker containers (not on host directly)
- Resource limits (CPU, memory, disk) enforced
- All commands logged with user context
- Alerts on dangerous commands (rm -rf, dd, etc.)

**Residual Risk**: Compromised agent could delete workspace, consume resources, or exfiltrate data.

**Future Improvement**: Use seccomp/AppArmor profiles to restrict syscalls.

### 3. No Rate Limiting on Agent Invocations

**Risk**: MEDIUM

**Description**: No limit on how many times an agent can be invoked or how long tasks can run.

**Justification**: Needed for complex, long-running tasks.

**Mitigations**:
- Manual monitoring of agent activity
- Resource limits prevent runaway processes
- Cost tracking for LLM API calls

**Residual Risk**: Abuse or bugs could lead to excessive LLM costs or resource exhaustion.

**Future Improvement**: Implement per-user/per-agent rate limits and cost budgets.

### 4. No Input Size Limits on Task Descriptions

**Risk**: MEDIUM

**Description**: Task descriptions can be arbitrarily large, potentially causing memory issues or prompt injection attacks.

**Justification**: Some legitimate tasks require long context.

**Mitigations**:
- LLM providers have their own context limits
- Large inputs logged for review

**Residual Risk**: Very large task descriptions could cause OOM errors or hide malicious content.

**Future Improvement**: Implement reasonable size limits (e.g., 50KB) with exceptions for approved use cases.

### 5. Hardcoded Credentials in Git History

**Risk**: CRITICAL (until addressed)

**Description**: Production database password `Mushroom1!Mushroom1!` was committed to git history in 15+ commits.

**Justification**: Accidental commits during rapid development.

**Mitigations**:
- Passwords will be rotated immediately
- `detect-secrets` pre-commit hook added
- Security training for all developers

**Residual Risk**: Anyone with git repo access (past or present) has seen the password.

**Future Improvement**: Rewrite git history to remove passwords, migrate to secret management system.

### 6. No Memory Poisoning Detection

**Risk**: MEDIUM

**Description**: Agents can write arbitrary data to the memory system; no validation that data is accurate or safe.

**Justification**: Memory system designed for agent autonomy.

**Mitigations**:
- Agent actions logged
- Memory can be reviewed and cleaned manually

**Residual Risk**: Malicious agent could inject false memories that affect future decisions.

**Future Improvement**: Implement memory verification, checksums, and trust scores.

---

## Security Goals

### Near-Term (Q1 2026)

1. ✅ Fix all hardcoded credentials in code
2. ⏳ Rotate all database passwords
3. ⏳ Implement Docker Secrets for local dev
4. ⏳ Add database activity logging
5. ⏳ Create agent security guidelines
6. ⏳ Document threat model

### Mid-Term (Q2 2026)

1. Migrate to Azure Key Vault
2. Implement least-privilege database users
3. Add API authentication (JWT tokens)
4. Implement rate limiting and cost budgets
5. Add content filtering for LLM outputs
6. Conduct penetration testing

### Long-Term (Q3-Q4 2026)

1. Implement agent sandbox with syscall filtering
2. Add memory poisoning detection
3. Implement managed identity for DB auth
4. Add request replay protection
5. Implement data classification/labeling
6. Build security monitoring dashboard

---

## Security Design Principles

### 1. Defense in Depth

Don't rely on a single security control. Layer multiple defenses:
- Container isolation + filesystem sandboxing + network segmentation
- Input validation + output sanitization + logging

### 2. Fail Secure

When in doubt, fail closed:
- Missing env var? Fail to start, don't use default
- Invalid input? Reject, don't sanitize and accept
- Authentication error? Deny access, don't log and continue

### 3. Least Privilege

Grant minimum permissions needed:
- Database users with minimal permissions
- Containers without root
- API keys with narrow scopes

### 4. Audit Everything

If it has security implications, log it:
- Shell commands executed
- Files accessed
- API calls made
- Authentication attempts

### 5. Assume Breach

Design as if an attacker is already inside:
- Segment networks
- Encrypt sensitive data at rest
- Monitor for unusual behavior
- Have incident response plan

---

## Compliance and Regulations

### Current Status

- **GDPR**: Not applicable (no EU user data)
- **HIPAA**: Not applicable (no healthcare data)
- **PCI-DSS**: Not applicable (no payment card data)
- **SOC 2**: Not pursued (no customers yet)
- **ISO 27001**: Not pursued (no requirement)

### Future Considerations

If Mycosoft becomes a service:
- **SOC 2 Type II**: For enterprise customers
- **ISO 27001**: For international customers
- **GDPR**: If EU users
- **CCPA**: If California users

---

## Incident Response Plan (High-Level)

### Phase 1: Detection
- Monitor logs for suspicious activity
- Alerts on failed auth, unusual commands
- Regular security audits

### Phase 2: Containment
- Isolate affected systems
- Revoke compromised credentials
- Block attacker access

### Phase 3: Eradication
- Remove malicious code/data
- Patch vulnerabilities
- Verify systems clean

### Phase 4: Recovery
- Restore from backups if needed
- Rotate all credentials
- Bring systems back online

### Phase 5: Lessons Learned
- Document incident
- Update security controls
- Train team on findings

---

## Review and Updates

This document should be reviewed and updated:
- **Quarterly**: During security audits
- **After Incidents**: When security issues occur
- **After Major Changes**: When architecture changes
- **Annually**: Comprehensive review

**Next Review**: May 12, 2026

---

## Acknowledgments

This document was created as part of the security hardening effort following the discovery of hardcoded credentials in the codebase (February 2026).

**Status**: Awaiting team review and approval
